/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package HSBA;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.sql.Clob;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Scanner;
import javax.swing.SwingWorker;
import ops.com.Utilities;
import ops.com.constant;
import ops.com.dbHandler;
import org.netbeans.api.progress.ProgressHandle;
import org.netbeans.api.progress.ProgressHandleFactory;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.windows.TopComponent;
import org.openide.util.NbBundle.Messages;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//HSBA//fbo//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "fboTopComponent",
        //iconBase="SET/PATH/TO/ICON/HERE", 
        persistenceType = TopComponent.PERSISTENCE_ALWAYS
)
@TopComponent.Registration(mode = "editor", openAtStartup = false)
@ActionID(category = "Window", id = "HSBA.fboTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(
        displayName = "#CTL_fboAction",
        preferredID = "fboTopComponent"
)
@Messages({
  "CTL_fboAction=Find Bad OTC",
  "CTL_fboTopComponent=Find Bad OTC Window",
  "HINT_fboTopComponent=This is a fbo window"
})
public final class fboTopComponent extends TopComponent implements PropertyChangeListener {

  class bgWorker extends SwingWorker<Void, Void> {

    @Override
    protected Void doInBackground() {
      disableButton();
      allowRunningState = true;
      pbar = ProgressHandleFactory.createHandle(mode);
      pbar.start();
      try {
        if (mode.equals("find brm")) {
          initFindBrm();
          pbar.switchToDeterminate(accno.size());
          getBrmDesc();

        } else if (mode.equals("find eai")) {
          initFindEai();
          pbar.switchToDeterminate(accno.size());
          getEaiDesc();
        } else if (mode.equals("patch brm")) {
          initPatchBrm();
          pbar.switchToDeterminate(accno.size());
          patchBrmDesc();
        }

      } catch (Exception e) {
        Utilities.logStack(me, e);
      }

      if (!allowRunningState) {
        Utilities.log(me, "Stopped", 2);
      }

      closeConnections();
      pbar.finish();
      enableButton();
      return null;
    }

  }

  public fboTopComponent() {
    initComponents();
    setName(Bundle.CTL_fboTopComponent());
    setToolTipText(Bundle.HINT_fboTopComponent());

  }

  /**
   * This method is called from within the constructor to initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jLabel2 = new javax.swing.JLabel();
    jLabel1 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();
    btnFind = new javax.swing.JButton();
    jScrollPane1 = new javax.swing.JScrollPane();
    txtAccNo = new javax.swing.JTextArea();
    jScrollPane2 = new javax.swing.JScrollPane();
    txtOtcDate = new javax.swing.JTextArea();
    jScrollPane3 = new javax.swing.JScrollPane();
    txtBRMDesc = new javax.swing.JTextArea();
    jScrollPane4 = new javax.swing.JScrollPane();
    txtEaiCandidate = new javax.swing.JTextArea();
    jLabel4 = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    btnStop = new javax.swing.JButton();
    jLabel6 = new javax.swing.JLabel();
    jXDatePicker1 = new org.jdesktop.swingx.JXDatePicker();
    btnPatch = new javax.swing.JButton();
    btnFindEai = new javax.swing.JButton();
    chkFutureBill = new javax.swing.JCheckBox();

    org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.jLabel2.text")); // NOI18N

    org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.jLabel1.text")); // NOI18N

    org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.jLabel3.text")); // NOI18N

    org.openide.awt.Mnemonics.setLocalizedText(btnFind, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.btnFind.text")); // NOI18N
    btnFind.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnFindActionPerformed(evt);
      }
    });

    txtAccNo.setColumns(20);
    txtAccNo.setRows(5);
    jScrollPane1.setViewportView(txtAccNo);

    txtOtcDate.setColumns(20);
    txtOtcDate.setRows(5);
    jScrollPane2.setViewportView(txtOtcDate);

    txtBRMDesc.setEditable(false);
    txtBRMDesc.setColumns(20);
    txtBRMDesc.setRows(5);
    jScrollPane3.setViewportView(txtBRMDesc);

    txtEaiCandidate.setEditable(false);
    txtEaiCandidate.setColumns(20);
    txtEaiCandidate.setRows(5);
    jScrollPane4.setViewportView(txtEaiCandidate);

    org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.jLabel4.text")); // NOI18N

    org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.jLabel5.text")); // NOI18N

    org.openide.awt.Mnemonics.setLocalizedText(btnStop, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.btnStop.text")); // NOI18N
    btnStop.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnStopActionPerformed(evt);
      }
    });

    org.openide.awt.Mnemonics.setLocalizedText(jLabel6, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.jLabel6.text")); // NOI18N

    org.openide.awt.Mnemonics.setLocalizedText(btnPatch, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.btnPatch.text")); // NOI18N
    btnPatch.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnPatchActionPerformed(evt);
      }
    });

    org.openide.awt.Mnemonics.setLocalizedText(btnFindEai, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.btnFindEai.text")); // NOI18N
    btnFindEai.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnFindEaiActionPerformed(evt);
      }
    });

    org.openide.awt.Mnemonics.setLocalizedText(chkFutureBill, org.openide.util.NbBundle.getMessage(fboTopComponent.class, "fboTopComponent.chkFutureBill.text")); // NOI18N
    chkFutureBill.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        chkFutureBillActionPerformed(evt);
      }
    });

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(layout.createSequentialGroup()
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
              .addComponent(jLabel1))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(jLabel3)
              .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(jLabel5)
              .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 187, javax.swing.GroupLayout.PREFERRED_SIZE)))
          .addGroup(layout.createSequentialGroup()
            .addComponent(jLabel6)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(jXDatePicker1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addComponent(chkFutureBill)))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(layout.createSequentialGroup()
            .addComponent(jScrollPane4)
            .addContainerGap())
          .addGroup(layout.createSequentialGroup()
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addGroup(layout.createSequentialGroup()
                .addGap(32, 32, 32)
                .addComponent(jLabel4))
              .addGroup(layout.createSequentialGroup()
                .addComponent(btnFind)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnFindEai)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnPatch)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnStop)))
            .addGap(0, 0, Short.MAX_VALUE))))
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(btnFind)
          .addComponent(btnStop)
          .addComponent(jLabel6)
          .addComponent(jXDatePicker1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(btnPatch)
          .addComponent(btnFindEai)
          .addComponent(chkFutureBill))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabel1)
          .addComponent(jLabel4)
          .addComponent(jLabel5)
          .addComponent(jLabel3))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 375, Short.MAX_VALUE)
          .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.TRAILING)
          .addComponent(jScrollPane4)
          .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING))
        .addContainerGap())
    );
  }// </editor-fold>//GEN-END:initComponents

  private void btnFindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFindActionPerformed
    // TODO add your handling code here:
    mode = "find brm";
    bgWorker bw = new bgWorker();
    bw.addPropertyChangeListener(this);
    bw.execute();


  }//GEN-LAST:event_btnFindActionPerformed

  private void btnFindEaiActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnFindEaiActionPerformed
    // TODO add your handling code here:
    mode = "find eai";
    bgWorker bw = new bgWorker();
    bw.addPropertyChangeListener(this);
    bw.execute();
  }//GEN-LAST:event_btnFindEaiActionPerformed

  private void btnPatchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPatchActionPerformed
    // TODO add your handling code here:
    mode = "patch brm";
    bgWorker bw = new bgWorker();
    bw.addPropertyChangeListener(this);
    bw.execute();
  }//GEN-LAST:event_btnPatchActionPerformed

  private void btnStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnStopActionPerformed
    // TODO add your handling code here:
    allowRunningState = false;
  }//GEN-LAST:event_btnStopActionPerformed

  private void chkFutureBillActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chkFutureBillActionPerformed
    // TODO add your handling code here:

    jXDatePicker1.setEnabled(!chkFutureBill.isSelected());

  }//GEN-LAST:event_chkFutureBillActionPerformed

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton btnFind;
  private javax.swing.JButton btnFindEai;
  private javax.swing.JButton btnPatch;
  private javax.swing.JButton btnStop;
  private javax.swing.JCheckBox chkFutureBill;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JLabel jLabel2;
  private javax.swing.JLabel jLabel3;
  private javax.swing.JLabel jLabel4;
  private javax.swing.JLabel jLabel5;
  private javax.swing.JLabel jLabel6;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JScrollPane jScrollPane2;
  private javax.swing.JScrollPane jScrollPane3;
  private javax.swing.JScrollPane jScrollPane4;
  private org.jdesktop.swingx.JXDatePicker jXDatePicker1;
  private javax.swing.JTextArea txtAccNo;
  private javax.swing.JTextArea txtBRMDesc;
  private javax.swing.JTextArea txtEaiCandidate;
  private javax.swing.JTextArea txtOtcDate;
  // End of variables declaration//GEN-END:variables

  ArrayList<String> accno;
  ArrayList<String> otcdate;
  ArrayList<String> brmdesc;
  ArrayList<String> eaidescs;
  ArrayList<String> eventUniquePoid;
  ArrayList<String> eventSeqPoid;
  ArrayList<String> eventEndDateTS;
  ArrayList<String> eventStartDateTS;
  ArrayList<String> EaiDescList;

  dbHandler dbhBRM;
  dbHandler dbhEAI;
  dbHandler dbhSBL;

  ProgressHandle pbar;

  PreparedStatement psBrmGetEvent;
  PreparedStatement psSblFindOrder;
  PreparedStatement psEaiGetOSMID;
  PreparedStatement psEaiGetEAIID;
  PreparedStatement psEaiGetWSREs;

  String me = "Find Bad OTC";
  boolean allowRunningState;
  String mode;

  private void initFindBrm() throws SQLException {

    accno = new ArrayList<String>();
    otcdate = new ArrayList<String>();
    brmdesc = new ArrayList<String>();
    eaidescs = new ArrayList<String>();
    eventUniquePoid = new ArrayList<String>();
    eventSeqPoid = new ArrayList<String>();
    eventEndDateTS = new ArrayList<String>();
    eventStartDateTS = new ArrayList<String>();
    EaiDescList = new ArrayList<String>();

    // load initial data
    Scanner sc = new Scanner(txtAccNo.getText());
    while (sc.hasNextLine()) {
      accno.add(sc.nextLine().trim());
      eventSeqPoid.add("");
      eventEndDateTS.add("");
      eventStartDateTS.add("");
      EaiDescList.add("");
    }

    sc.close();
    sc = new Scanner(txtOtcDate.getText());
    while (sc.hasNextLine()) {
      otcdate.add(sc.nextLine().trim());
    }

    if (accno.size() != otcdate.size()) {
      Utilities.popup("Mismatch input count");
      allowRunningState = false;
      return;
    }

    connectApps();
//    connectEAI();
//    connectSBL();

    String futureTable = "";
    String futureCOndition = "";

    if (chkFutureBill.isSelected()) {
      futureTable = "  , pin.billinfo_t tbi \n";
      futureCOndition = "  and ta.poid_Id0 = tbi.account_obj_Id0\n"
              + "  and tb.poid_id0 = tbi.bill_obj_id0\n";
    } else {
      try {
        String billdate = Utilities.tsToDate(jXDatePicker1.getDate().getTime() / 1000, "yyyyMMdd");
        long billdatets = Utilities.dateToTS(billdate, "yyyyMMdd");
        futureCOndition = "  and tb.end_t = " + billdatets + " \n";
      } catch (NullPointerException e) {
        Utilities.popup("Please select bill date");
        allowRunningState = false;
        return;
      }

    }

    psBrmGetEvent = dbhBRM.createPS("select\n"
            + "  te.sys_descr, te.poid_id0, te.end_t, te.start_t \n"
            + "from\n"
            + "  pin.account_t ta\n"
            + "  , pin.bill_t tb\n"
            + "  , pin.item_t ti\n"
            + "  , pin.event_t te\n"
            + futureTable
            + " where\n"
            + "  ta.account_no = ? \n"
            + futureCOndition
            + "  and te.end_T between ? and ( ? + 86400)\n"
            + "  and te.poid_type = '/event/billing/product/fee/purchase'\n"
            + "  and ta.poid_Id0 = tb.account_obj_Id0\n"
            + "  and tb.poid_id0 = ti.bill_obj_id0\n"
            + "  and ti.poid_Id0 = te.item_obJ_id0");

  }

  private void initFindEai() throws SQLException {
    if (accno.isEmpty()) {
      Utilities.popup("No input to process");
      allowRunningState = false;
      return;
    }

    connectEAI();
    connectSBL();

    psSblFindOrder = dbhSBL.createPS("SELECT distinct order_num,  \n"
            + "a.created+1/3 cdate, a.last_upd+1/3 updatedate\n"
            + ", (a.last_upd - a.created) * 86400 dif\n"
            + "FROM siebel.s_order a, siebel.s_order_type b, siebel.s_order_item c, siebel.s_prod_int d, siebel.s_org_ext e,\n"
            + "siebel.s_order_x f,\n"
            + "siebel.s_order_item_x g\n"
            + "WHERE a.order_type_id = b.row_id\n"
            + "AND c.order_id = a.row_id\n"
            + "AND d.row_id = c.prod_id\n"
            + "AND e.par_row_id = a.bill_accnt_id\n"
            + "AND f.par_row_id = a.row_id\n"
            + "AND g.par_row_id = c.row_id\n"
            + "and (a.last_upd + 1/3) >= to_date( ? ,'DD-MM-YYYY HH24:MI:SS')\n"
            + "and (a.created+1/3)  < to_date( ? ,'DD-MM-YYYY HH24:MI:SS')\n"
            + "and b.name = 'New Install'\n"
            + "and ou_num = ? \n"
            + "and x_service_inst_id is null\n"
            + "order by dif");
    // sort by create/update time diff, smaller means no exception

    psEaiGetOSMID = dbhEAI.createPS("select b.ext_msg_id as OSM_ID\n"
            + "from (select * from wliprd_custom.EAI_AUDIT_LOG where event_name='OrderCreate' and AUDIT_TYPE='RQI') a left outer join \n"
            + "(select * from wliprd_custom.EAI_AUDIT_LOG where EVENT_NAME='OrderCreate'\n"
            + "and AUDIT_TYPE in ('WSResponse', 'ERROR')) b on a.int_msg_id = b.int_msg_id\n"
            + "where a.EXT_MSG_ID = ? and b.ext_msg_id is not null ");

    psEaiGetEAIID = dbhEAI.createPS("Select A.Int_Msg_Id\n"
            + "From Wliprd_Custom.Eai_Audit_Log A "
//            + "left join Wliprd_Custom.Eai_Error_Log B\n"
//            + "    on B.Integration_Msg_Id In A.Int_Msg_Id\n"
            + "Where A.Ext_Msg_Id = ? \n"
            + "  And A.Event_Name = 'BillingActivate' "
            + "  and A.Audit_Param_3 = 'One Time Charge' \n"
            + "Order By Ext_Msg_Id desc, Audit_Date_Time desc");

    psEaiGetWSREs = dbhEAI.createPS("Select\n"
            + "  audit_date_time, audit_type,audit_param_3, payload\n"
            + "From Wliprd_Custom.Eai_Audit_Log \n"
            + "Where Int_Msg_Id = ? \n"
            + "  and Audit_Date_Time <= to_date( ? ,'DD-MM-YYYY HH24:MI:SS')\n"
            //            + "  and Audit_Type in ('WSResponse', 'WSRequest')\n"
            + "Order By Audit_Date_Time Desc");

  }

  private void initPatchBrm() throws SQLException {
    if (accno.isEmpty()) {
      Utilities.popup("No input to process");
      allowRunningState = false;
      return;
    }

    connectApps();

    psBrmGetEvent = dbhBRM.createPS("update event_t set sys_descr = ? where poid_id0 = ? ");

  }

  private void getBrmDesc() {

    for (int i = 0; i < accno.size(); i++) {

      if (!allowRunningState) {
        break;
      }

      String bano = accno.get(i);
      //Utilities.log(me, "----------------------------------", 0);

      pbar.progress(bano, i);

      long odate = Utilities.dateToTS(otcdate.get(i), "dd/MM/yyyy");
      boolean found = false;

      String evepoid = "";
      String desc = "Not found or already exist above";
      String dateTS;

      try {
        psBrmGetEvent.setString(1, bano);
        psBrmGetEvent.setLong(2, odate);
        psBrmGetEvent.setLong(3, odate);

        ResultSet rs = psBrmGetEvent.executeQuery();

        while (rs.next()) {
          evepoid = dbHandler.dbGetString(rs, 2);
          dateTS = dbHandler.dbGetString(rs, 3);
          String currDesc = dbHandler.dbGetString(rs, 1);
          String sdateTS = dbHandler.dbGetString(rs, 4);

          //Utilities.log(me, currDesc + " - event " + evepoid + " " + dateTS, 1);
          if (currDesc.contains("Contract") || currDesc.contains("Activation")) {
            continue;
          }

          if (found) {

            if (desc.toUpperCase().contains("BTU") || desc.toUpperCase().contains("UNRECOVER")) {
              // means currnent is an ok desc. replace it
              desc = "Not found or already exist above";
              if (!eventUniquePoid.contains(evepoid)) {
                desc = dbHandler.dbGetString(rs, 1);

                found = true;
                eventUniquePoid.add(evepoid);
                eventSeqPoid.set(i, evepoid);
                eventEndDateTS.set(i, dateTS);
                eventStartDateTS.set(i, sdateTS);
              }
            }

          } else {
            if (!eventUniquePoid.contains(evepoid)) {
              desc = dbHandler.dbGetString(rs, 1);
              found = true;
              eventUniquePoid.add(evepoid);
              eventSeqPoid.set(i, evepoid);
              eventEndDateTS.set(i, dateTS);
              eventStartDateTS.set(i, sdateTS);
            }
          }
        }

        brmdesc.add(desc);
        txtBRMDesc.setText(getTextFromList(brmdesc));
      } catch (Exception e) {
        e.printStackTrace();
      }

    }

    txtBRMDesc.setText(getTextFromList(brmdesc));

  }

  private void getEaiDesc() {
    for (int i = 0; i < accno.size(); i++) {

      if (!allowRunningState) {
        break;
      }

      String bano = accno.get(i);
      String eventpoid = eventSeqPoid.get(i);
      String evdate = eventStartDateTS.get(i);

      pbar.progress(bano, i);

      if (eventpoid.isEmpty()) {
        Utilities.log(me, bano + " - no event found", 1);
        continue;
      }

      //Utilities.log(me, bano + " - event " + eventpoid + " " + evdate, 1);
      String evDateTs = Utilities.tsToDate(Long.parseLong(evdate) + 1, "dd-MM-yyyy HH:mm:ss");
      boolean foundExact = false;

      // first, get order from siebel
      try {
        psSblFindOrder.setString(1, evDateTs);
        psSblFindOrder.setString(2, evDateTs);
        psSblFindOrder.setString(3, bano);

        ResultSet rsSbl = psSblFindOrder.executeQuery();
        while (rsSbl.next()) {

          if (foundExact) {
            // skip the rest if already found the exact order (that return exact event poid)
            break;
          }

          String OrderNum = dbHandler.dbGetString(rsSbl, 1);
          Utilities.log(me, bano + " order num: " + OrderNum, 1);

          // find OSM id
          psEaiGetOSMID.setString(1, OrderNum);
          ResultSet rsOSMID = psEaiGetOSMID.executeQuery();
          if (rsOSMID.next()) {

            String OSMID = dbHandler.dbGetString(rsOSMID, 1);
            Utilities.log(me, OrderNum + " OSM ID: " + OSMID, 1);

            psEaiGetEAIID.setString(1, OSMID);
            ResultSet rsEAIid = psEaiGetEAIID.executeQuery();

            while (rsEAIid.next()) {
              if (foundExact) {
                // skip the rest if already found the exact order (that return exact event poid)
                break;
              }

              String EAIID = dbHandler.dbGetString(rsEAIid, 1);
              foundExact = EaiInternalFind(EAIID, evDateTs, i);
            }

          } else {
            Utilities.log(me, "No OSMID for order#" + OrderNum, 1);
          }

        }
      } catch (SQLException e) {
        Utilities.log(me, "error searching for BA#" + bano, 1);
        Utilities.logStack(me, e);
      }

      txtEaiCandidate.setText(getTextFromList(EaiDescList));

    }
  }

  private boolean EaiInternalFind(String EAIID, String datets, int pos) {
    boolean retval = false;
    String currEventPoid = eventSeqPoid.get(pos);
    Utilities.log(me, "Processing  " + EAIID, 0);
    try {
      psEaiGetWSREs.setString(1, EAIID);
      psEaiGetWSREs.setString(2, datets);

      boolean exception = false;

      ResultSet rs = psEaiGetWSREs.executeQuery();

      if (rs.next()) {
        // this should be the JMSRequest
        String audit_type = dbHandler.dbGetString(rs, "audit_type");
        String audit_param_3 = dbHandler.dbGetString(rs, "audit_param_3");
        if (audit_type.equals("JMSRequest")) {
          exception = !audit_param_3.equals("Success");
        } else {
          // something is wrong. skip it
          Utilities.log(me, "First result is not a JMSRequest for " + EAIID, 1);
          return false;
        }

        if (!exception) {
          // not exception, this should be the WSResponse
          if (rs.next()) {
            audit_type = dbHandler.dbGetString(rs, "audit_type");
            if (audit_type.equals("WSResponse")) {
              String eaiEpoid = getEaiEventPoid(rs.getClob("payload"));
              // found the actual eai order task for this. or not
              retval = eaiEpoid.equals(currEventPoid);
            } else {
              Utilities.log(me, "second result for non exception is not WSResponse for " + EAIID + ". found " + audit_type, 1);
              return false;
            }
          } else {
            Utilities.log(me, "no second result for non exception. Expected WSResponse for " + EAIID, 1);
            return false;
          }

        }

        // next, get the WSRequest for 40009
        if (rs.next()) {
          audit_type = dbHandler.dbGetString(rs, "audit_type");
          audit_param_3 = dbHandler.dbGetString(rs, "audit_param_3");
          if (audit_type.equals("WSRequest") && audit_param_3.equals("40009")) {
            String descFromEai = parseEaiDesc(rs.getClob("payload"));
            EaiDescList.set(pos, descFromEai);
          } else {
            Utilities.log(me, "Expected WSRequest 40009 for " + EAIID + ". found " + audit_type + " " + audit_param_3, 1);
            return false;
          }
        } else {
          Utilities.log(me, "Expected WSRequest for " + EAIID, 1);
          return false;
        }

      } else {

        Utilities.log(me, "no result for  " + EAIID, 1);
      }

    } catch (SQLException e) {
      Utilities.log(me, "error searching for EAIID#" + EAIID, 1);
      Utilities.logStack(me, e);
    }

    return retval;
  }

  private String parseEaiDesc(Clob b) throws SQLException {
    String retval = "";
    Scanner sc = new Scanner(b.getAsciiStream());

    while (sc.hasNextLine()) {
      String data = sc.nextLine();

      if (data.contains("</DESCR>")) {
        retval = getFullPoid(data);
        break;
      }
    }

    sc.close();

    return retval;
  }

  private String getEaiEventPoid(Clob b) throws SQLException {
    String retval = "";
    Scanner sc = new Scanner(b.getAsciiStream());

    while (sc.hasNextLine()) {
      String data = sc.nextLine();

      if (data.contains("/event/billing/product/fee/purchase")) {
        retval = getPoid(data);
        break;
      }
    }

    sc.close();

    return retval;
  }

  private String getFullPoid(String xmlLine) {
    String right = xmlLine.substring(xmlLine.indexOf(">"));
    return right.substring(1, right.indexOf("<"));
  }

  private String getPoid(String xmlLine) {
    String right = xmlLine.substring(xmlLine.indexOf(">"));
    String poid = right.substring(1, right.indexOf("<"));

    return poid.split(" ")[2];

  }

  private String getTextFromList(ArrayList<String> input) {

    StringBuilder sb = new StringBuilder();
    String newline = constant.LINE_SEPARATOR;

    for (String aa : input) {
      sb.append(aa);
      sb.append(newline);
    }

    return sb.toString();

  }

  private void patchBrmDesc() {

    if (!allowRunningState) {
      return;
    }

    for (int i = 0; i < accno.size(); i++) {
      if (!allowRunningState) {
        break;
      }

      String eventPoid = eventSeqPoid.get(i).trim();
      String eaiDesc = EaiDescList.get(i).trim();

      if (eventPoid.isEmpty() || eaiDesc.isEmpty()) {
        Utilities.log(me, "Empty event / EAI desc for BA#" + accno.get(i), 3);
        continue;
      }

      try {
        psBrmGetEvent.setString(1, eaiDesc);
        psBrmGetEvent.setString(2, eventPoid);

        int upcount = psBrmGetEvent.executeUpdate();

        if (upcount != 1) {
          Utilities.log(me, upcount + " record updated for BA#" + accno.get(i), 1);
        }

      } catch (SQLException e) {
        Utilities.log(me, "error patching for BA#" + accno.get(i), 1);
        Utilities.logStack(me, e);
      }

    }

    Utilities.popup("Patch Completed!!1");

  }

  @Override
  public void componentOpened() {
    // TODO add custom code on component opening
  }

  @Override
  public void componentClosed() {
    // TODO add custom code on component closing
  }

  void writeProperties(java.util.Properties p) {
    // better to version settings since initial version as advocated at
    // http://wiki.apidesign.org/wiki/PropertyFiles
    p.setProperty("version", "1.0");
    // TODO store your settings
  }

  void readProperties(java.util.Properties p) {
    String version = p.getProperty("version");
    // TODO read your settings according to their version
  }

  @Override
  public void propertyChange(PropertyChangeEvent evt) {

  }

  private void enableButton() {
    btnStop.setEnabled(false);
    btnFindEai.setEnabled(true);
    btnPatch.setEnabled(true);
    btnFind.setEnabled(true);
  }

  private void disableButton() {
    btnStop.setEnabled(true);
    btnFindEai.setEnabled(false);
    btnPatch.setEnabled(false);
    btnFind.setEnabled(false);
  }

  // functions
  // <editor-fold defaultstate="collapsed" desc="connections">  
  void connectApps() throws SQLException {
    dbhBRM = new dbHandler("apps");
    dbhBRM.setDBConnInfo(constant.dbConApps);
    dbhBRM.setUserPass(constant.dbConUser, constant.dbConPass);
    dbhBRM.openConnection();
  }

  void connectEAI() throws SQLException {
    dbhEAI = new dbHandler("EAI");
    dbhEAI.setDBConnInfo(constant.dbConEAI);
    dbhEAI.setUserPass(constant.dbEAIUser, constant.dbEAIPass);
    dbhEAI.openConnection();
  }

  void connectSBL() throws SQLException {
    dbhSBL = new dbHandler("SBL");
    dbhSBL.setDBConnInfo(constant.dbConSBL);
    dbhSBL.setUserPass(constant.dbSBLUser, constant.dbSBLPass);
    dbhSBL.openConnection();
  }

  void closeConnections() {
    try {
      if (dbhBRM != null) {
        dbhBRM.closeConnection();
      }
      if (dbhSBL != null) {
        dbhSBL.closeConnection();
      }

      if (dbhEAI != null) {
        dbhEAI.closeConnection();
      }

    } catch (Exception e) {
      Utilities.logStack(me, e);
    }

  }
  //</editor-fold>

}
